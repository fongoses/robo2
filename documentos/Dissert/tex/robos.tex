%==========================================================
% Robôs Móveis.
% 
% Autor
% Heitor Luis Polidoro
% 
% Orientador
% Prof. Dr. Denis Fernando Wolf
%==========================================================

\chapter{Robôs Móveis}
\label{robos}

\section{Locomoção}
\label{locomocao}
Robôs móveis precisam de mecanismos de locomoção que os permitam moverem-se livremente pelo ambiente, mas existe uma grande variedade de meios de se locomover, andar, pular, correr, deslisar, patinar, nadar, voar, e utilizando rodas ou esteiras \cite{Siegwart2004}. A maioria dos mecanismos de locomoção são inspirados na natureza, exceto os que usam rodas, esteiras ou propulsão (aquática ou aérea).

Robôs com rodas são os mais populares por inúmeras razões. Robôs com rodas são mecanicamente simples de construir. A razão da carga peso/mecanismo é favorável. Os outros mecanismos geralmente precisam de um hardware mais complexo para carregarem a mesma carga \cite{Jones1999}. São mais eficientes em gasto de potência por velocidade como mostra na Figura \ref{fig:potencia_por_velocidade}. Além disso, como os robôs com rodas são projetados para as rodas estarem em contato com o chão todo o tempo, o equilíbrio não é usualmente um problema pesquisado \cite{Siegwart2004}.

\figura{imagens/grafico_potencia_por_velocidade.png}{.5}{Potência por velocidade de vários mecanismos de locomoção: (a) Rastejar e deslizar. (b) Correr. (c) Pneu em chão suave. (d) Andar. (e) Em ferrovia. (1) Unidade de potência (Cavalos/toneladas). (2) Velocidade (milhas/hora)\cite{Siegwart2004}{fig:potencia_por_velocidade}

Ao invés de se preocupar com o equilíbrio, as pesquisas em robôs com rodas tendem a focar em problemas como tração, estabilidade, manobrabilidade e controle \cite{Siegwart2004}. 

Existem quatro classes principais de rodas, como é mostrado na Figura \ref{fig:tipos_de_rodas}. Elas se diferenciam grandemente na sua cinemática, e portanto a escolha da classe de roda tem um grande impacto na cinemática do robô móvel. A roda padrão e a roda castor tem um eixo primário de rotação e são portanto altamente direcionais. Para mover em uma direção diferente, a roda precisa ser direcionada primeiro ao longo do eixo vertical. A diferença enter essas duas rodas é que a roda padrão consegue concluir seu direcionamento sem efeitos colaterais, como o centro de rotação passa pelo contato com o chão, ao passo que a roda castor rotaciona em torno de um eixo deslocado, causando uma força a ser transmitida para o chassi do robô durante o direcionamento \cite{Siegwart2004}.

\figura{imagens/tipos_de_roda.png}{.6}{Quatro tipos básicos de roda. (a) Roda padrão. (b) Roda castor. (c) Roda sueca. (d) Bola ou roda esférica\cite{Siegwart2004}{fig:tipos_de_rodas}

A roda sueca e a roda esférica são ambas projetos que estão menos condicionadas pelas direcionalidade do que a convencional roda padrão. As funções da roda sueca são as de uma roda normal, mas provêm baixa resistência em outra direção, alguma vezes perpendicular à direção convencional, como a Sueca 90, e algumas vezes em um ângulo intermediário, como a Sueca 45. Os pequenos roletes ao redor da roda são passivos. A vantagem principal desse modelo é que enquanto a rotação é provida somente através de um eixo principal, a roda pode cinematicamente mover-se com pouco atrito em diferentes possíveis trajetórias, não somente para frente e para trás \cite{Siegwart2004}.

A roda esférica é uma roda omnidirecional verdadeira, muitas vezes projetada de modo que ela possa ser alimentada ativamente para girar ao londo de qualquer direção. Um modo para implementar a roda esférica é imitar o \textit{mouse} do computador, provendo ativamente rolamentos alimentados que encostam na superfície superior da esfera e concedem força rotacional \cite{Siegwart2004}.

A principal desvantagem das rodas é que elas necessitam de uma rua ou uma superfície relativamente plana \cite{Braunl2008}, em terrenos desiguais, elas podem ter uma performance pobre. Genericamente, se a altura do objeto for aproximadamente o raio da roda. Uma solução simples seria utilizar rodas grandes o suficiente comparada com todos os possíveis obstáculos, mas em muitos casos isso é impraticável \cite{Jones1999}.

\section{Sensores}
\label{sensores}
Uma das tarefas mais importantes em um sistema autônomo de qualquer tipo é adquirir conhecimento sobre o ambiente. Isso é feito pegando medidas usando vários sensores e extraindo informações significativas dessas medidas \cite{Siegwart2004}. Existe um vasto número de sensores sendo usados em robótica, aplicando diferentes técnicas de medidas, e usando diferentes interfaces \cite{Braunl2008}. Como humanos, nós conseguimos ver uma xícara em cima da mesa, e sem pensar muito conseguimos pegar essa xícara. De fato, completar a simples tarefa de alcançar e erguer uma xícara requer uma combinação complexa de sensores, interpretação, cognição e coordenação \cite{Jones1999}.

Alguns sensores são utilizados para medidas simples como a temperatura interna de robô ou a velocidade de rotação dos motores, mas outros mais sofisticados podem ser utilizados para adquirir informação sobre o ambiente ou até para medir diretamente a posição global do robô \cite{Siegwart2004}. 

Podemos classificar os sensores em dois importantes eixos funcionais: proprioceptivo/exteroceptivo e passivo/ativo \cite{Siegwart2004}.
\textbf{Proprioceptivo}, são os sensores que medem valores internos ao sistema, como velocidade do motor, bateria, ângulo dos braços por exemplo.
\textbf{Exteroceptivo}, são os sensores que adquirem informações sobre o ambiente do robô, como medidos de distância, intensidade de luz, amplitude do som por exemplo. Conseqüentemente as medidas de sensores exteroceptivos são interpretadas pelo robô, para extrair as informações significantes do ambiente.
\textbf{Passivos}, são sensores que medem a energia do ambiente que entra no sensor. Por exemplo: sondas de temperatura, microfones e câmeras.
\textbf{Ativos}, são sensores que emitem energia para o ambiente, então medem a reação do ambiente à essa energia. Sensores deste tipo têm uma performance superior, entretanto existem alguns riscos, como a falta de energia pode afetar a característica que o sensor está tentando medir. Sensores ativos também podem sofrer interferências de sinais que estão fora do seu controle. Por exemplo, sinais emitidos por robôs próximos, ou sensores similares no mesmo robô, podem influenciar no resultado das medidas. Exemplos de sensores ativos incluem sensores ultra-sônicos, sonares, e LASERs para medir distância \cite{Siegwart2004}.

\section{Robô Pioneer}
\label{robo_pioneer}

O Pioneer (Figura \ref{fig:pioneer}) é o robô disponível para testes experimentais no Laboratório de Robótica Móvel (ICMC - USP), ele é um robô móvel ágil, versátil e inteligente. Construído em um sistema cliente-servidor, ele oferece um processamento de visão \textit{onboard}, comunicação \textit{ethernet}, LASER, GPS, sonar, e outras funções autônomas. E para programá-lo deve-se utilizar a biblioteca Player \cite{MobileRobots}.

\figura{imagens/pioneer.jpg}{.9}{Robô Pioneer.}{fig:pioneer}

\section{Controle do Robô}
\label{controle_do_robo}
O controle do robô será desenvolvido utilizando-se a biblioteca Player/Stage \cite{Gerkey2003}, a qual permite que sejam realizadas simulações antes que os algoritmos sejam testados com o robô real. Essas simulações são importantes para o aperfeiçoamento dos parâmetros, como distâncias, velocidades, etc, antes do teste no Pioneer.


\subsection{Player}
\label{player}
O Player é um servidor de rede para controlar robôs. Executando embarcado no robô, o Player provê uma interface simples e clara dos sensores e atuadores do robô sobre uma rede IP. O programa cliente ``conversa'' com o Player utilizando sockets TCP, lendo dados dos sensores, escrevendo comandos nos atuadores e configurando dispositivos em tempo de execução.
O servidor Player foi desenvolvido para que seus clientes sejam independentes de linguagem e de plataforma. O programa cliente pode executar em qualquer máquina que tenha conexão de rede com o robô, e pode ser escrito em qualquer linguagem que suporte sockets TCP. Atualmente existem clientes disponíveis em C++, Tcl, Java e Phyton \cite{Player}. Futuramente, o Player não fará suposições sobre como o programa de controle do robô é estruturado, ou seja, poderá escrever desde programas multi-threads altamente concorrentes até programas sequências simples.

\subsection{Stage}
\label{stage}
O Stage é usado normalmente como um plugin para o Player, provendo uma série de dispositivos virtuais para os clientes Player. Os usuários escrevem as rotinas e algoritmos normalmente, como clientes para um servidor Player. Não é possível para clientes distinguir a diferença entre os dispositivos reais do robô e os equivalentes simulados pelo Player/Stage. Com isso clientes Player desenvolvidos usando o Stage precisarão de pouca ou nenhuma modificação para trabalhar com o robô real, e vice-versa. Em muitos casos basta somente mudar no cliente o endereço IP de onde está o servidor. O Stage também pode simular uma população de robôs móveis, sensores e objetos num ambiente bidimensional (Figura \ref{fig:stage}) \cite{Player}. Nesta dissertação será utilizado somente um robô e o sensor LASER.

\figura{imagens/stage.jpg}{.5}{Simulação com 5 robôs, 2 objetos, LASER, sonar e blobfinder.}{fig:stage}
