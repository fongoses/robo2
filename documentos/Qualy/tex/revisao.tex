%========================================================== 
% Capitulo 2: Revisão Bibliográfica.
% 
% Autor Heitor Luis Polidoro
% 
% Orientador Prof.  Dr.  Denis Fernando Wolf
%==========================================================

\chapter{Revisão Bibliográfica} 
\label{revisao_bibliografica} 

\section{Navegação} 
\label{navegacao} 
Existe uma série de problemas não resolvidos na robótica móvel.  Uma questão aberta tem a ver com dotar um robô com a habilidade de navegar em seu ambiente \cite{Jones1999}.  A navegação é a ciência, arte, prática ou tecnologia, de planejar e percorrer uma trajetória de um ponto de origem até um ponto de destino. 

Em robótica, navegação é a ciência de direcionar o percurso de um robô móvel enquanto percorre o meio ambiente (terra, água, ou ar).  Inerente em qualquer esquema de navegação é o desejo de alcançar um destino sem se perder ou colidir com alguma coisa \cite{Mckerrow1991}.  Em geral, navegação é um processo incremental que, segundo \cite{Murphy2000}, pode ser resolvido respondendo à quatro perguntas:

\begin{itemize} 
	\item \textbf{Para onde estou indo?} Geralmente determinado por um humano ou uma missão; 
	\item \textbf{Qual o melhor caminho?} Esse é o problema de planejamento de trajetória, e é a área da navegação que recebe mais atenção; 
	\item \textbf{Por onde passei?} Enquanto o robô explora o ambiente, pode ser parte da missão mapear esse ambiente; 
	\item \textbf{Onde estou?} Para seguir uma trajetória ou construir um mapa o robô precisa saber onde ele está.  
\end{itemize}

Que podem ser sumarizadas em quatro passos, segundo \cite{Goldberg1995}:

\begin{itemize} 
	\item Percepção e modelagem do ambiente; 
	\item Localização; 
	\item Planejamento e decisão do movimento; 
	\item Execução do movimento; 
\end{itemize}

A relação entre esses passos pode ser vista na figura \ref{fig:fluxo_navegacao} \cite{Mckerrow1991}.

\figura{imagens/fluxo_navegacao.jpg}{.4}{Hierarquia do controle de um robô móvel, mostrando o fluxo de informação.}{fig:fluxo_navegacao}

Navegação é a instância do paradigma geral da robótica ``perceber - decidir - agir''.  A implementação da tarefa de navegação pode ser mais ou menos complexa, depende do contexto em que a tarefe vai ser executada \cite{Goldberg1995}.

\begin{itemize} 
	\item \textbf{O ambiente:} pode ser inicialmente conhecido, parcialmente conhecido, ou completamente desconhecido, pode ser estático ou com objetos móveis, et al.; 
	\item \textbf{A meta:} pode ser especificada por \textit{landmarks} ou coordenadas; 
	\item \textbf{A navegação em si:} pode ter restrições como: tempo, melhor caminho, et al.; 
	\item \textbf{As habilidades do robô:} poder de computação, sensores e suas incertezas, tamanho do robô e sua cinemática, et al.  
\end{itemize}

A solução para o problema de navegação vai depender de todas essas restrições \cite{Goldberg1995}.

A navegação pode ser dividida em duas grandes áreas: planejamento de trajetória e desvio de obstáculos.  O planejamento de trajetória consistem em, dado uma representação do ambiente (total ou parcial) o robô deve planejar uma trajetória que o leve do seu ponto de origem até seu destino, atendendo a requisitos como menor caminho ou  menos curvas por exemplo.  O desvio de obstáculos é utilizado principalmente em ambientes dinâmicos, onde possam haver obstáculos móveis, e sua função é fazer com que o robô chegue em seu destino de forma segura, ou seja, não colida com obstáculos que podem ser móveis ou não, utilizando sensores geralmente de distância, como LASERs e sonares, ou até mesmo utilizando câmeras.

\subsection{Planejamento de Trajetória} 
\label{planejamento} 
O primeiro passo para planejar uma trajetória é transformar um possível modelo contínuo do ambiente em um mapa discreto compatível com o algoritmo de planejamento de trajetória escolhido.  É possível identificar três estratégias gerais de composição \cite{Siegwart2004}: 

\begin{itemize} 
	\item \textit{Roadmap}: identificar um conjunto de rotas nos espaços livres; 
	\item Decomposição em células: discriminar entre células livres e ocupadas; 
	\item Campos potenciais: impor uma função matemática sobre o espaço.  
\end{itemize}

\subsubsection{\textit{Roadmap}} 
\label{roadmap} 
A técnica de \textit{roadmap} para planejamento de trajetórias consiste em capturar a conectividade do espaço livre do ambiente em uma rede de curvas.  Essa rede é vista como um conjunto padrão de caminhos.  O planejamento da trajetória então se reduz à conectar os pontos inicial e final do robô no \textit{roadmap} e buscar neste um caminho entre esses dois pontos. Se existir um caminho ele será dado pela junção de três sub caminhos: um sub caminho entre o ponto inicial até algum ponto do \textit{roadmap}, um sub caminho do \textit{roadmap} e um sub caminho do \textit{roadmap} até o ponto final \cite{Ottoni2000}

Vários métodos propostos foram baseados nessa idéia, dentre eles: grafos de visibilidade, diagrama de Voronoi, rede de caminho livre, e silhueta.  Neste projeto será utilizado diagrama de Voronoi. 

\paragraph{Diagrama de Voronoi} 
\label{voronoi} 
Diagrama de Voronoi é um método completo de mapa de rotas que tende à maximizar a distância enter o robô e os obstáculos no mapa.  Para cada ponto livre no mapa é calculada a distância para o obstáculo mais próximo. O diagrama de Voronoi consiste nos pontos que são eqüidistantes de um ou mais obstáculos.  Um exemplo de diagrama de Voronoi em um mapa pode ser visto na figura \ref{fig:exemplo_voronoi} \cite{Siegwart2004}.

\figura{imagens/exemplo_voronoi.jpg}{.4}{Exemplo de um diagrama de Voronoi.}{fig:exemplo_voronoi}

O diagrama de Voronoi tem uma fraqueza importante no caso sensores de localização com alcance limitado.  Como os algoritmo maximiza a distância entre o robô e um objeto no ambiente, qualquer sensor de curto alcance no robô poderá falhar para perceber ao seu redor. Se o sensor de curto alcance está sendo usado para localização, então o caminho designado pelo diagrama de Voronoi será pobre num ponto de vista para localização \cite{Siegwart2004}.

Por outro lado, como por definição o caminho é criado baseado em um ponto eqüidistante dos obstáculos, isso garante um rota segura do robô pelo mapa.

\paragraph{Decomposição em Células} 
\label{decomposicao_celulas} 
Este método consiste em dividir o espaço livre do mapa em células, de forma que um caminho entre quaisquer duas células possa ser facilmente obtido. Um grafo, chamado \textit{grafo de conectividade}, representa a relação de adjacência enter as células.  Onde os vértices representam as células extraídas do espaço livre.  Somente existe uma aresta entre dois vértices se e somente se as células correspondentes foram adjacentes.  O resultado de um caminho é uma seqüência de células denominada \textit{canal}, de onde pode ser computado um caminho contínuo \cite{Ottoni2000}.  A Figura \ref{fig:decomposicao_celulas} demonstra um exemplo de de mapa utilizando decomposição em células.

\figura{imagens/decomposicao_celulas.jpg}{.5}{Exemplo de um mapa com decomposição em células.}{fig:decomposicao_celulas}

\paragraph{Campos Potenciais} 
\label{campos_potenciais}
Neste método o espaço livre é discretizado em uma fina grade, a cada posição é associado uma função, com a qual pode-se fazer uma analogia a um campo potencial.  Como o tamanho da grade é grande, pois ela é fina, são utilizados métodos heurísticos para encontrar um caminho. A analogia que o método sugere é que o robô seja uma partícula movendo-se sob a influência de um campo potencial gerado pelos obstáculos e pelo seu ponto de destino. O ponto de destino gera um campo potencial que atrai o robô, enquanto os obstáculos geram um campo que repele o robô. O caminho final é dado pela força resultante desses campos potenciais. 

Um exemplo de campos potenciais é mostrado na Figura \ref{fig:campos_potenciais}.  O campo potencial atrativo (b) é um parabolóide com ponto de mínimo localizado na posição do objetivo.  O campo potencial repulsivo (c) é diferente de zero somente a partir de uma determinada distância dos obstáculos. O caminho (e) é construído pela direção oposta a do gradiente do potencial resultante (d). Em (f) temos uma matriz de orientações do vetor gradiente, que são as orientações das forças induzidas pelo campo potencial \cite{Ottoni2000}.

\figura{imagens/campos_potenciais.jpg}{.5}{Exemplo de um mapa com campos potenciais.}{fig:campos_potenciais}

\subsection{Desvio de Obstáculos} 
\label{desvio} 
Recentemente, muitas pesquisas voltaram sua atenção para o problema de desvio de obstáculos.  Entretanto, existe alguns métodos clássicos de desvio de obstáculos que dever ser citados \cite{Borenstein1991}: Detecção de borda, \textit{certainty grid}, campos potenciais, campo de força virtual e vector field histogram. 

Detecção de borda, é um método bem popular que extrai as bordas verticais do objeto, e guia o robô ao redor dessas bordas. 

\textit{Certainty grid} é um método de representação probabilístico de obstáculos que modela o mundo em uma grade, onde a área de trabalho do robô é modelada em um arranjo de quadrados em 2D, chamada células.  Cada célula tem um valor de certeza que indica o grau de confiança de que algum objeto está na área dessa célula. 

O método de campos potenciais funciona tanto para planejamento de trajetória quanto para desvio de obstáculos, para isso basta calcular a força potencial resultante em tempo de execução, com isso o robô poderá desviar de obstáculos móveis

O campo de força virtual (do inglês \textit{Virtual Force Field} - VFF) é um método para veículos que necessitam de uma resposta mais rápida para fazer curvas. É um método baseado na \textit{certainty grid}, onde uma grade de histograma cartesiano 2D é usado para representar a probabilidade de cada célula conter um obstáculo, depois a idéia de campos potenciais é aplicada ao histograma.

E por fim o método de \textit{vector field histogram} - VFH, que cria um mapa de \textit{certainty grid} local, e ao invés de utilizar um histograma cartesiano 2D, utiliza um histograma polar ($\alpha-P$), onde $\alpha$ é o ângulo do sensor e $P$ é a probabilidade de haver um obstáculo nessa direção. O VFH é explicado melhor a seguir.

Foi implementado o método de campos potencias, mas após alguns testes verificou-se que o método VFH já implementado no Player, é mais rápido e mais eficiente.

\subsubsection{\textit{Vector Field Histogram}}
\label{VFH}
Analisando melhor o método VFF percebemos um problema: redução drástica excessiva dos dados quando forças de repulsão individuais do histograma da grade de células são somadas para calcular o vetor resultante. Centenas de pontos de dados são reduzidos em um passo para direção e magnitude. Conseqüentemente, informações detalhadas sobre a distribuição local do obstáculo é perdida. Para remedias essa situação, foi desenvolvido um novo método chamado \textit{Vector Field Histogram} - VFH. O Método VFH utiliza dois estágios de redução de dados \cite{Borenstein1991}.

Existem três níveis de representação de dados \cite{Borenstein1991}:

\begin{itemize}
	\item O nível mais contém uma descrição detalhada do ambiente do robô;
	\item No nível intermediário é armazenado um histograma polar unidimensional sobre a localização momentânea do robô;
	\item O nível mais baixo é a saída do algoritmo VFH, valores de referência para o controle de movimento do robô
\end{itemize}

No primeiro estágio da redução de dados é mapeado a grade de histograma do ambiente (Figura \ref{fig:histogram_grid})em um histograma polar (Figura \ref{fig:polar_histogram}). E no segundo estágio computa a direção $\theta$ para onde o robô deve virar.

\figura{imagens/histogram_grid.png}{.3}{(a) Exemplo de um mapa. (b) Grade de histograma correspondente.}{fig:histogram_grid}

\figura{imagens/polar_histogram.png}{.3}{(a) Densidade polar de obstáculo em um histograma polar relativo à posição do robô em $O$ (Figura \ref{fig:histogram_grid}(b)). (b) O mesmo histograma polar de (a) mostrado em forma polar e por cima da grade de histograma da Figura \ref{fig:histogram_grid}(b).}{fig:polar_histogram}


\subsection{Representação do Mapa}
\label{mapa}
Representar o ambiente onde o robô se encontra é importante pois, decisões baseadas na representação do ambiente pode ter impacto nas escolhas disponíveis para a representação da posição do robô. Muitas vezes a fidelidade da representação da posição é limitada pela fidelidade do mapa \cite{Siegwart2004}.

Segundo \cite{Siegwart2004}, três relações fundamentais tem de ser entendidas quando se escolha uma representação particular de mapa:
\begin{itemize}
	\item A precisão do mapa precisa ser compatível com a precisão da necessidade do robô para atingir seus objetivos;
	\item A precisão do mapa e o tipo de dados dos recursos representados precisam ser compatíveis com a precisão e os tipo de dados retornados pelos sensores do robô;
	\item A complexidade da representação do mapa tem impacto direto com a complexidade computacional.	
\end{itemize}

Existem várias maneira de representar um mapa: Decomposição por célula, decomposição fixa, decomposição adaptada (com variação de célula), \textit{occupancy grid} e representação topológica, et al. \cite{Siegwart2004}. %Dentre essas vale destaca a representação topológica, que será utilizada no projeto.

\subsection{Grafos}
\label{grafos}
Muitas aplicações em computação necessitam considerar um conjunto de conexões entre objetos. Os relacionamentos dessas conexões podem ser utilizados para responder questões como: Existe caminho de um objeto a outro? Quantos objetos podem ser alcançados a partir de um determinado objeto? Qual a menor distância entre dois objetos? Existe um tipo abstrato de dados chamado grafo que é usado para modelar essas situações \cite{Ziviani2004}

Um grafo é constituído de um conjunto de vértices e um conjunto de arestas que conectam pares de vértices. Um vértice é um objeto que pode conter nomes e outros atributos. Os grafos podem ser direcionados ou não direcionados. Um grafo direcionado $G$ é um par $(V, A)$, em que $V$ é um conjunto finito de vértices e $A$ é um conjunto de arestas com uma relação binária. A Figura \ref{fig:exemplo_de_grafos}\subref{fig:grafo_dir} mostra um grafo direcionado com o conjunto de vértices $V = {0, 1, 2, 3, 4, 5}$ e de arestas $A = {(0, 1), (0, 3), (1, 2), (1, 3), (2, 2), (2, 3), (3, 0), (5, 4)}$. Em um grafo não direcionado as arestas $(u, v)$ e $(v, u)$ são consideradas as mesmas. A Figura \ref{fig:exemplo_de_grafos}\subref{fig:grafo_ndir} mostra um grafo não direcionado com o conjuntos de vértices $V = {0, 1, 2, 3, 4, 5}$ e de arestas $A = {(0, 1), (0, 2), (1, 2), (4, 5)}$. Em grafos direcionados podem existir arestas de um vértice para ele mesmo, chamadas de \textit{self-loops}, como a aresta $(2, 2)$ no grafo direcionado da figura \ref{fig:exemplo_de_grafos}\subref{fig:grafo_dir} \cite{Ziviani2004}.

\begin{figure}[ht]
	\centering
	\subfigure[Grafo direcionado]{
		\includegraphics[width=0.2\textwidth]{imagens/grafo_direcionado.jpg}
		\label{fig:grafo_dir}}
	\subfigure[Grafo não direcionado]{
		\includegraphics[width=0.2\textwidth]{imagens/grafo_nao_direcionado.jpg}
		\label{fig:grafo_ndir}}
	\caption{Exemplo de grafos}
	\label{fig:exemplo_de_grafos}
\end{figure}

Em um grafo direcionado, a aresta $(u, v)$ sai do vértice $u$ e entra no vértice $v$. Se $(u, v)$ é uma aresta do grafo $G = (V, A)$, então o vértice $v$ é adjacente ao vértice $u$. Quando o grafo não é direcionado, a relação de adjacência é simétrica \cite{Ziviani2004}.

Em um grafo, um caminho $(v_0, v_1, \cdots, v_k)$ forma um clico se $v_0 = v_k$ e o caminho contém pelo menos uma aresta. O ciclo é simples se os vértices $v_1, v_2, \cdots, v_k$ são distintos. O \textit{self-loop} é um ciclo de tamanho 1. Na figura \ref{fig:exemplo_de_grafos}\subref{fig:grafo_dir}, o caminho $(0, 1, 2, 3, 0)$ forma um ciclo. Dois caminhos $(v_0, v_1, \cdots, v_k)$ e $(v'_0, v'_1, \cdots, v'_k)$ formam o mesmo ciclo se existir um inteiro $j$ tal que $v'_i = v_{(j+i) mod k}$ para $i = 0, 1, \cdots, k - 1$. Na figura \ref{fig:exemplo_de_grafos}\subref{fig:grafo_dir}, o caminho $(0, 1, 3, 0)$ forma o mesmo ciclo que os caminhos $(1, 3, 0, 1)$ e $(3, 0, 1, 3)$. Um grafo sem ciclos é um grafo acíclico \cite{Ziviani2004}.

Um grafo $G$ é definido como \textit{Hamiltoniano} se possui um ciclo contendo todos os vértices de $G$. Esse nome foi dado pois, em 1856, Willian Rowan Hamilton inventou um jogo matemático que consistia em um dodecaedro no qual cada um dos vinte vértices recebeu o nome de uma cidade. O objetivo do jogo era viajar pelas arestas do dodecaedro, visitando cada cidade exatamente uma vez e retornando para o ponto inicial \cite{Beineke1978}. A figura \ref{fig:dodecaedro_de_hamilton} mostra uma solução para o jogo.

\figura{imagens/dodecaedro_de_hamilton.jpg}{.5}{Dodecaedro de Hamilton.}{fig:dodecaedro_de_hamilton}

Definições segundo \cite{Gondran1984}:

\begin{itemize}
	\item Um caminho passando somente uma vez em cada vértice de $G$ é chamado Caminho Hamiltoniano e tem comprimento de $N - 1$
	\item Um ciclo Hamiltoniano é um ciclo que passa somente uma vez em cada vértice de $G$ e tem comprimento $N$.
\end{itemize}

Um grafo não direcionado é conectado se cada par de vértices está conectado por um caminho. Um grafo direcionado é fortemente conectado se cada dois vértices quaisquer são alcançáveis a partir um do outro. Um grafo ponderado possui pessoa associados às suas arestas. Esses pesos podem representar, por exemplo, custos ou distâncias. Um grafo completo é um grafo no qual todos os pares de vértices são adjacentes \cite{Ziviani2004}.

\subsection{Busca do Menor Caminho}
\label{busca_do_menor_caminho}
%
\subsubsection{Algoritmo de Dijkstra}
\label{algoritmo_de_dijkstra}
Existem diversos algoritmos para buscas em grafo na literatura \cite{Cormen2001}. Neste trabalho foi utilizado o algoritmo de Dijkstra. O algoritmo de Dijkstra utiliza a técnica do relaxamento, que nada mais é que verifica se é possível melhorar o caminho obtido até o momento passando por um vértice diferente. O algoritmo de Dijkstra apresenta uma solução $O([m + n] × log(n))$ para a determinação do menor caminho \cite{Dudek2000}. E é composto por três passos.

\begin{itemize}
	\item Passo 1: Iniciar os valores:

\begin{algorithmic}
	\FORALL {$v \in V[G]$} 
	\STATE$	d[v] \gets \infty$
	\STATE$ \pi[v] \gets  nulo$
	\ENDFOR
	\STATE	$d[s] \gets 0$
\end{algorithmic}

	$V[G]$ é o conjunto de vértices $v$ que forma o grafo $G$.
	$d[v]$ é o vetor de distâncias do vértice $s$ até cada vértice $v$.
	$\pi[v]$ identifica o vértice de onde se origina uma conexão até $v$ de maneira a formar um caminho mínimo.

	\item Passo 2: Temos que usar dois conjuntos: $S$, que representa todos os vértices $v$ onde $d[v]$ já contém o custo do menor caminho e $Q$ que contém os vértices restantes.

	\item Passo 3: Realizamos uma série de relaxamentos das arestas:
\begin{algorithmic}
	\WHILE {$Q \neq \emptyset $}
		\STATE$u \gets$ \texttt{extraia-mín($Q$)}
		\STATE $S \gets S \cup {u}$
		\FORALL{$v$ adjacente a $u$}
			\STATE se $d[v] > d[u] + w(u, v)$ então 
			\STATE $d[v] \gets d[u] + w(u, v)$
			\STATE $\pi[v] \gets u$
		\ENDFOR
	\ENDWHILE
\end{algorithmic}
		$w(u, v)$ é o peso da aresta que vai de $u$ a $v$.
		$u$ e $v$ são vértices quaisquer e $s$ é o vértice inicial.
		\texttt{extraia-mín($Q$)}, retorna o menor elemento.
		
\end{itemize}

\subsection{Caixeiro-viajante}
\label{caixeiro}

O problema do caixeiro-viajante envolve um conjunto de cidades é da classe de problemas de roteamento de nós, onde um caixeiro sai de uma cidade base, visita todas as cidades somente uma vez, e retorna à cidade base, otimizando um ou mais objetivos. Problemas de caixeiro-viajante são definidos em grafos orientados ou não orientados \cite{Arenales2007}

A definição do problema do caixeiro-viajante é: Considere um grafo não orientado $G = (N, E)$, em que o conjunto $N$ consistem em $n$ cidades e $E$ representa o conjunto de arestas entra essas cidades. Supondo que $G$ é um grafo completo, isto é, para qualquer par de cidades $i, j \in \mathbb{N}, i \neq j$, existe uma aresta $(i, j)$. A distância entre as cidades $i$, e $j$ é $c_{ij}$, e quando $c_{ij} = c_{ji}$, o problema é dito simétrico. Um caixeiro deve visitar $n$ cidades, passando por cada cidade somente uma vez, e retornar à cidade de partida. Esse percurso é denominado ciclo Hamiltoniano do grafo $G$, e o problema consiste em determinar o ciclo Hamiltoniano, ou rota, de distância mínima. Devido à sua aplicação em diversas áreas, este é um dos problemas combinatórios mais pesquisados \cite{Arenales2007}.

Defina as variáveis

\begin{center}
$
x_{ij}=\left\{ \begin{array}{l}
			1  \mbox{ se o caixeiro vai diretamente da cidade $i$ à cidade $j$}, i \neq j \\
			0  \mbox{ se o caixeiro não vai da cidade $i$ à cidade $j$}, i \neq j
		\end{array}\right.
$
\end{center}

E considere o seguinte modelo:

\begin{equation}
	\mbox{min}\sum_{i=1}^n \sum_{j > i}c_{ij}x_{ij} 
	\label{eq:cv-func_obj}
\end{equation}

\begin{equation}
	\sum_{j < i} x_{ji} + \sum_{j > i} x_{ij} = 2, i = 1, \cdots, n
	\label{eq:cv-restr1}
\end{equation}

\begin{equation}
	x \in B^{n(n-1)/2}
	\label{eq:cv-restr2}
\end{equation}

A função objetivo (\ref{eq:cv-func_obj}) expressa a minimização da distância total da rota, e as restrições (\ref{eq:cv-restr1}) impõe que cada cidade tenha somente uma cidade sucessora imedia e uma cidade predecessora imediada, ou seja, é visitada uma única vez. Uma solução para o modelo anterior pode gerar sub-rotas desconexas (Figura \ref{fig:sub-rotas}) \cite{Arenales2007}.

\figura{imagens/sub-rotas.jpg}{.4}{Exemplo de possíveis sub-rotas.}{fig:sub-rotas}

Seja $S$ uma sub-rota, por exemplo, $S = {1. 2. 3. 4}$ na Figura \ref{fig:sub-rotas}. A eliminação de sub-rotas pode ser obtida através da restrição
\begin{equation}
	\sum_{i \in S} \sum_{i \ in S \\ j > i} \leq |S| - 1, S \subset \mathbb{N}, 3 \leq |S| \leq \left\lfloor \frac{n}{2} \right\rfloor
	\label{eq:cv-el_sub-rotas1}
\end{equation}
que garante que, para cada conjunto $S$, existem no mínimo duas arestas que entram e/ou saem de $S$, ou seja, existem no mínimo duas arestas entre cidades de $S$ e cidades fora de $S$. A cardinalidade de $S$ é no mínimo 3 (pois ciclo em um grafo não orientado tem pelo menos 3 vértices) e no máximo $\left\lfloor\frac{n}{2}\right\rfloor$, pois ao se eliminar ciclos com $k$ vértices, eliminamos ciclos com $n - k$ vértices. A sub-rota $S = {1, 2, 3, 4}$ é eliminada.
\begin{center}
	$x_{15} + x_{16} + x_{17} + x_{25} + x_{26} + x_{27} + x_{35} + x_{36} + x_{37} + x_{45} + x_{46} + x_{47} \geq 2$
\end{center}

Uma forma alternativa de eliminar sub-rotas é com a seguinte restrição
\begin{equation}
	\sum_{i \in S} \sum_{i \ in S \\ j > i} \leq |S| - 1, S \subset \mathbb{N}, 3 \leq |S| \leq \left\lfloor \frac{n}{2} \right\rfloor
	\label{eq:cv-el_sub-rotas2}
\end{equation}
que corresponde a eliminar uma aresta da sub-rota. A sub-rota $S = {1, 2, 3, 4}$ é eliminada.
\begin{center}
	$x_{12} + x_{23} + x_{34} + x_{14} \leq 3$
\end{center}

Como o número de subconjuntos distintos de um conjunto de cardinalidade $k$ é $2^k$, as restrições \ref{eq:cv-el_sub-rotas1} e \ref{eq:cv-el_sub-rotas2} têm cardinalidade da ordem de $2^k$, $k \geq 6$, ou seja, o crescimento é exponencial em função do número de cidades. Para $k \leq 5$, somente a restrição \ref{eq:cv-restr1} elimina sub-rotas \cite{Arenales2007}.

\section{Controle do Robô}
\label{controle_do_robo}
O controle do robô será desenvolvido utilizando-se a biblioteca Player/Stage \cite{Gerkey2003}, a qual permite que sejam realizadas simulações antes que os algoritmos sejam testados com o robô real (Figura \ref{fig:gazebo_pioneer}). Essas simulações são importantes para o aperfeiçoamento dos parâmetros, como distâncias, velocidades, etc, antes do teste no Pioneer.

\begin{figure}[ht]
	\centering
	\subfigure[Gazebo]{
		\includegraphics[width=0.55\textwidth]{imagens/gazebo.jpg}
		\label{fig:gazebo}}
	\subfigure[Pioneer]{
		\includegraphics[width=0.35\textwidth]{imagens/pioneer.jpg}
		\label{fig:pioneer}}
	\caption{Robô Pioneer, Simulado e Real.}
	\label{fig:gazebo_pioneer}
\end{figure}

\subsection{Player}
\label{player}
O Player é um servidor de rede para controlar robôs. Executando embarcado no robô, o Player provê uma interface simples e clara dos sensores e atuadores do robô sobre uma rede IP. O programa cliente ``conversa'' com o Player utilizando sockets TPC, lendo dados dos sensores, escrevendo comandos nos atuadores e configurando dispositivos em tempo de execução.
O servidor Player foi desenvolvido para ser independente de linguagem e de plataforma. O programa cliente pode executar em qualquer máquina que tenha conexão de rede com o robô, e pode ser escrito em qualquer linguagem que suporte sockets TCP. Atualmente existem clientes disponíveis em C++, Tcl, Java em Phyton \cite{Player}. Futuramente, o Player não fará suposições sobre como o programa de controle do robô é estruturado, ou seja, poderá-se escrever desde programas multi-threads altamente concorrentes até programas seqüências simples.

\subsection{Stage}
\label{stage}
O Stage é usado normalmente como um plugin para o Player, provendo uma série de dispositivos virtuais para os clientes Player. Os usuários escrevem as rotinas e algoritmos normalmente, como clientes para um servidor Player. Não é possível para clientes distinguir a diferença entre os dispositivos reais do robô e os equivalentes simulados pelo Player/Stage. Com isso clientes Player desenvolvidos usando o Stage precisarão de pouca ou nenhuma modificação para trabalhar com o robô real, e vice-versa. Em muitos casos basta somente mudar no cliente o endereço IP de onde está o servidor. O Stage também pode simular uma população de robôs móveis, sensores e objetos num ambiente bi-dimensional (Figura \ref{fig:stage}) \cite{Player}. Neste projeto será utilizado somente um robô e o sensor LASER.

\figura{imagens/stage.jpg}{.5}{Simulação com 5 robôs, 2 objetos, LASER, sonar e blobfinder.}{fig:stage}

