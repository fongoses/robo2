/*
 * =====================================================================================
 *
 *       Filename:  matriz_esparsa.cpp
 *
 *    Description:  Implementacao da classe MatrizEsparsa
 *
 *        Version:  1.0
 *        Created:  10/02/2008 06:33:31 PM
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Heitor Luis Polidoro (hlp), heitor@icmc.usp.br
 *        Company:  ICMC - USP São Carlos
 *
 * =====================================================================================
 */
#include	<cstdlib>
#include	<cfloat>

#include	"matriz_esparsa.h"

/*
 *--------------------------------------------------------------------------------------
 *       Class:  MatrizEsparsa
 *      Method:  MatrizEsparsa
 * Description:  constructor
 *--------------------------------------------------------------------------------------
 */
MatrizEsparsa::MatrizEsparsa ()
{
  raiz = new CelulaEsparsa();
//	linha = new CelulaEsparsa();
//	coluna = new CelulaEsparsa();

//	raiz->linha = linha;
//	raiz->coluna = coluna;

//	total_linhas = total_colunas = -1;
}  /* -----  end of method MatrizEsparsa::MatrizEsparsa  (constructor)  ----- */

/*
 *--------------------------------------------------------------------------------------
 *       Class:  MatrizEsparsa
 *      Method:  MatrizEsparsa
 * Description:  destructor
 *--------------------------------------------------------------------------------------
 */

MatrizEsparsa::~MatrizEsparsa()
{
  CelulaEsparsa *aux, *l, *c;

  l = raiz->getProxLinha();

  while(l != NULL) {
    c = l->getProxColuna();
    while(c != NULL) {
      aux = c;
//      printf("Liberou [%2d, %2d] = %2.2f\t", coluna->l, coluna->c, coluna->valor);
      c = c->getProxColuna();
      delete(aux);
    }
    l = l->getProxLinha();
  }
  delete(raiz);
}  /* -----  end of method MatrizEsparsa::~MatrizEsparsa  (constructor)  ----- */

	int
MatrizEsparsa::adicionarCelula ( int l, int c, float v )
{
	CelulaEsparsa *aux, *nova;
	aux = getCelula(l, c);
printf("Adicionando [%d, %d] = %f\n", l, c, v);
	if(aux != NULL) {
		cerr << "Celula [" << l << ", " << c << "] Já existe! Sobreescrevendo o valor."  << endl;
		aux->setValor(v);
	} else {
		/* Aumentando os dimensoes da matriz, se necessario */
//		while(c + 1> (int)coluna.size()) {
//			coluna.push_back(aux2);
//	imprimir();cout << 10;
//			cout << coluna.size() << "/" << c << endl;getchar();
//		}
//	imprimir();getchar();cout << 10.50 << endl;
		while(l + 1> (int)linha.size()) {
			aux = new CelulaEsparsa();
			aux->setLinha((int)linha.size());
			aux->setColuna(0);
			linha.push_back(*aux);
		}

//		for(int i = (int)coluna.size(); i < c; i++) {
//			coluna.push_back(i);
//		}
//		if(c + 10 > (int)coluna.size()) {
//			coluna.resize(c + 5);
//		}
//		if(l + 10 > (int)linha.size()) {
//			linha.resize(l + 5);
//		}

		nova = new CelulaEsparsa(l, c, v);

		/* localizando a posicao onde a nova celula tem que ser inserida */
//		aux = &coluna[c];
//		/* Enquanto a proxima celula existir, ou a pocisao da linha for depois da nova celula */
//		while((aux->getProxLinha() != NULL) && (aux->getProxLinha()->getLinha() < l)) {
//			aux = aux->getProxLinha();
//		}

//		nova->setProxLinha(aux->getProxLinha());
//		aux->setProxLinha(nova);

		aux = &linha[l];
		aux->imprimir();getchar();
if(aux->getProxColuna() != NULL) {cout << aux->getProxColuna()->getColuna() << endl;getchar();}
		/* Enquanto a proxima celula existir, ou a pocisao da coluna for depois da nova celula */
		while((aux->getProxColuna() != NULL) && (aux->getProxColuna()->getColuna() > c)) {
			aux = aux->getProxColuna();
		aux->imprimir();getchar();
		}

cout << "A Anterior" << endl;aux->imprimir();cout << "nova" << endl;nova->imprimir();getchar();
		nova->setProxColuna(aux->getProxColuna());
cout << "X Anterior" << endl;aux->imprimir();cout << "nova" << endl;nova->imprimir();getchar();
		aux->setProxColuna(nova);
cout << "D Anterior" << endl;aux->imprimir();cout << "nova" << endl;nova->imprimir();getchar();
	}


	cerr << "addCelula incompleto!!!" << endl;
	return 0;
}		/* -----  end of method MatrizEsparsa::adicionarCelula  ----- */

	CelulaEsparsa
*MatrizEsparsa::getCelula ( int l, int c )
{
	CelulaEsparsa *aux;;
	if((l <= (int)linha.size()/* || c <= (int)coluna.size()*/)) {
		/* localizando a posicao onde a nova celula tem que ser inserida */
		aux = &linha[c];
		/* Enquanto a proxima celula existir, ou a pocisao da linha for depois da nova celula */
		while((aux->getProxColuna() != NULL) && (aux->getProxColuna()->getColuna() != l)) {
			aux = aux->getProxColuna();
		}
		return aux->getProxColuna();
	} else {
		return NULL;
	}
}		/* -----  end of method MatrizEsparsa::getCelula  ----- */

	float
MatrizEsparsa::getValor ( int l, int c )
{
	CelulaEsparsa *aux;

	aux = getCelula(l, c);
	if(aux != NULL) {
		return aux->getValor();
	} else {
		return -FLT_MAX;
	}

}		/* -----  end of method MatrizEsparsa::getValor  ----- */

	void
MatrizEsparsa::imprimir (  )
{
	int l, c;
	for ( l = 0; l < (int)linha.size(); l += 1 )
		for ( c = 0; c < (int)linha.size(); c += 1 )
			if(getCelula(l, c) != NULL)
				cout << "[" << l << ", " << c << "]=>" << getValor(l, c) << endl;

			return ;
}		/* -----  end of method MatrizEsparsa::imprimir  ----- */

