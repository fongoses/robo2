%==========================================================
% Resultados Obtidos.
% 
% Autor
% Heitor Luis Polidoro
% 
% Orientador
% Prof. Dr. Denis Fernando Wolf
%==========================================================

\chapter{Resultados Obtidos}
\label{resultados_obitdos}

\section{Objetivo}
\label{objetivo}
Essa dissertação tem como objetivo o desenvolvimento de uma estratégia eficiente para determinar uma seqüência de áreas a serem visitadas em ambientes internos com a finalidade de monitoramento desses ambientes utilizando um robô móvel. O problema a ser resolvido consiste na divisão de um ambiente previamente conhecido em áreas de interesse (exemplo na Figura \ref{fig:mapa_museu}). A cada uma dessas áreas é atribuído um valor (peso) referente a sua importância de monitoramento (exemplo na Tabela \ref{tab:prioridade_museu}). A prioridade com que o robô deve visitar determinadas áreas é calculada com base na importância dessas áreas e no tempo decorrido desde a sua última visita. Áreas de maior importância devem ser visitadas mais freqüentemente. 

\figura{../../imagens/MUSEU_DO_HOMEM_SERGIPANO.jpg}{8}{Exemplo de mapa: Museu do homem sergipano e suas divisões}{fig:mapa_museu}

\begin{table}\begin{center}
	\begin{tabular}
		{|c|c|}
		\hline
		Sala & Prioridade \\
		\hline
		a& 5 \\
		b& 5 \\
		c& 2 \\
		d& 1 \\
		e& 3 \\
		f& 2 \\
		g& 1 \\
		h& 2 \\
		i& 2 \\
		j& 4 \\
		k& 4 \\
		l& 4 \\
		1& 2 \\
		2& 3 \\
		3& 3 \\
		4& 5 \\
		5& 5 \\
		6& 5 \\
		7& 4 \\
		8& 4 \\
		9& 3 \\
		\hline
	\end{tabular}
\end{center}
\caption{Exemplo de prioridades}
\label{tab:prioridade_museu}
\end{table}

\subsection{Critérios de Avaliação}
\label{criterios}
Os algoritmos e estratégias serão então testados e avaliados. As avaliações consistem na comparação dos algoritmos e estratégias. Serão utilizados dois critérios de comparação, um critério comparando a freqüência relativa de cada sala com sua prioridade relativa, onde o melhor resultado é aquele em que a freqüência relativa se aproximar mais da prioridade relativa, pois se uma sala (a) possui uma prioridade com valor duas vezes maior que uma sala (b) (Salas f e 7 na Figura \ref{tab:prioridade_museu} por exemplo), a sala (a) deve ser visitada com o dobro de freqüência do que a sala (b). Isto indica que o algoritmo ou estratégia se manteve fiel à definição do problema: \textit{ Áreas de maior importância devem ser visitadas mais freqüentemente.}.

O segundo critério é um gráfico mostrando a progressão da somatória dos graus de urgência de todas as salas $(\sum_{i=0}^n U_i)$ , no qual o melhor resultado consiste em manter o menor valor da somatória dos graus de urgência. Mostrando que o algoritmo ou estratégia visitou as salas com maior eficiência. O grau de urgência $U$ é calculado multiplicando-se a prioridade da sala $P$ pelo tempo decorrido desde a última visita $t$. A casa visita o $t$ é zerado $(U_i = P_i \times t_i)$.

\section{Metodologia}
\label{metodologia}

Cada ambiente tem um mapa topológico que será gerado utilizando o diagrama de Voronoi. O robô então, deve utilizar deste mapa para se locomover de uma sala para outra no ambiente. Para os algoritmos e estratégias determinarem a seqüência de salas à visitar, é considerado um grafo completo com todas as salas, pois para determinar o melhor caminho entre uma sala e outra será utilizado o algoritmo de Dijkstra no mapa topológico.

Como um dos critérios de avaliação está relacionado ao tempo que o robô fica sem visitar as salas é possível deduzir que a solução seja um ciclo.

\pagebreak

Considere:
\begin{itemize}
	\item Um ambiente com $S$ salas;
	\item Um ciclo hamiltoniano $C$ qualquer;
	\item $C_i$ é a i-ésima sala visitada no ciclo;
	\item Uma velocidade constante do robô (tanto linear quanto angular);
	\item $\Delta t_i$ o tempo para sair da sala $i$ e chegar na sala $i+1$.
\end{itemize}

Como o tempo de viagem de entre as mesmas salas é constante todos os $\Delta t_i$ são constantes, portanto o tempo total do ciclo $T$ é constante $(\sum_{i=1}^S \Delta t_i = cte)$. Se o tempo do ciclo é constante, o tempo que o robô demora para revisitar cada sala é constante igual a $T$. Mas isso não é interessante para solução do problema pois o grau de urgência de cada sala é diferente, então se uma sala tem uma prioridade muito alta, seu grau de urgência vai ser muito alto até o robô revisitá-la. 

Para resolver esse problema, basta fazer com que o robô revisite essa(s) sala(s) mais de uma vez no ciclo. Então supondo um ciclo de tamanho $n$ sendo $n \geq S$ o tempo total do ciclo continua constante $(\sum_{i=1}^n \Delta t_i = cte)$. Portanto a solução do problema consiste em encontrar esse ciclo.

\section{Soluções}
\label{solucoes}

Foram definidas dois tipos de soluções, uma solução \textbf{\textit{offline}}, ou seja, a solução é calculada em um computador e depois informado ao robô qual seqüência de sala ele deve seguir, essa seqüência não é alterada. E a outra solução é uma solução \textbf{tempo real}, ou seja, o robô define para qual sala deve ir durante a execução do algoritmo, baseando suas decisões no que está acontecendo no momento. A solução \textit{\textbf{offline}} é dividida em duas partes: \textbf{Gerador}, que cria possíveis seqüências de salas ótimas, e o \textbf{Avaliador} que analisa e computa uma nota para as seqüências de salas criadas pelo \textbf{Gerador}
MENCIONAR AS DUAS SOLUÇÕES, OFFLINE E REAL TIME.
EXPLICAR QUE A OFFLINE É DIVIDIDA EM 2: GERADOR E AVALIADOR. OK?

\subsection{\textit{Offline}}
\label{offline}
Esse método consiste em explorar as diversas possíveis combinações de seqüências de salas para encontrar a seqüência ótima. Um programa chamado \texttt{gerador}, seguindo uma determinada heurística, gera as possíveis seqüências de salas, essas seqüências são fornecidas ao programa \texttt{avaliador} que, baseado no critério de maior Grau de Urgência Total, analisa a seqüência e retorna uma avaliação ao \texttt{gerador} que tomara a decisão de: descartar a seqüência, preservar a seqüência para gerar futuras seqüências ou guardar a seqüência como possível seqüência ótima.

\subsubsection{Avaliador}
\label{avaliador}

O programa chamado \texttt{avaliador} é utilizado para avaliar os candidatos a seqüência de salas ótima do mapa analisado gerado pelo programa \texttt{gerador} \ref{gerador} e retorna para o \texttt{gerador} um valor numérico, baseado nesse valor o \texttt{gerador} irá guardar a seqüência como possível ótima, descartar ou continuar utilizando essa seqüência para gerar novas seqüência. Maiores detalhes na sessão \ref{gerador}.

%\subsubsection{Funcionamento}
%\paragraph{Funcionamento}

O \texttt{avaliador} recebe três parâmetros como entrada:
\begin{itemize}
	\item O nome do mapa onde o caminho será avaliado;
	\item Um vetor de vértices, representando a seqüência de salas a ser avaliada;
	\item Um valor opcional de limite para a avaliação.
\end{itemize}

Com esses parâmetros o \texttt{avaliador} inicia a simulação do robô navegando pelo mapa. A velocidade linear, que determina a velocidade com que o robô anda para frente ou para trás, é definida pela constante \texttt{SIMULACAO\_VEL} como 1 m/s. E a velocidade angular, que determina a velocidade com que o robô vira, é definida pela constante \texttt{SIMULACAO\_ROT} como 0.5 rad/s. Ambas constantes estão no arquivo \texttt{robo.h}. O tempo que o robô demora para visitar uma sala é definido pela constante \texttt{VISITAR\_SALA} como 5 s no arquivo \texttt{salas.h}.

Durante a simulação, a cada visita de sala o \texttt{avaliador} mede o Grau de Urgência Total e salva o maior valor, esse valor vai ser a avaliação do caminho neste mapa. Após a simulação o \texttt{avaliador} verifica se caso a avaliação do caminho for maior que o limite fornecido o valor 0 (zero) é retornado, se nenhum limite for fornecido o \texttt{avaliador} utiliza o valor do maior inteiro do compilador. Se o caminho não visita todos as salas o \texttt{avaliador} retorna a avaliação com valor negativo, se todas as salas foram visitadas o \texttt{avaliador} verifica se o caminho é um \textit{loop}, ou seja, se o caminho começa e termina no mesmo vértice, caso contrário ele também retorna a avaliação em valor negativo.  Se o caminho for um \textit{loop}, visita todas as salas e o valor da avaliação for menor que o limite fornecido (ou menor que o maior inteiro do compilador), o valor da avaliação, maior Grau de Urgência Total em todo o percurso, é retornado pelo \texttt{avaliador}.

Para critério de parada o \texttt{avaliador} compara o estado das salas, ou seja, se para cada sala, o Grau de Urgência e o número de visitas é o mesmo ao término do caminho.

A Figura\ref{fig:fluxograma_avaliador} mostra o fluxograma do programa \texttt{avaliador} e o algoritmo \ref{alg:avaliador} contém seu pseudocódigo.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{../../imagens/fluxograma_avaliador.png}
	\caption{Fluxograma do \texttt{avaliador}}
	\label{fig:fluxograma_avaliador}
\end{figure}


%\subsection{Algoritmo}

\begin{algorithm}[htbp]
\caption{\texttt{avaliador}}
\label{alg:avaliador}
\begin{algorithmic}[1]
\REQUIRE mapa, caminho, limite = \texttt{INT\_MAX} 
\ENSURE A avaliação do $caminho$ no $mapa$
	\STATE carregar ($mapa$)
	\STATE $aval \leftarrow 0$
	\REPEAT
		\STATE $salas\_anterior \leftarrow salas\_atual$
		\FORALL {vértice $v$ em $caminho$}
			\STATE Calcula o tempo necessário para o robô chegar ao vértice $v$
			\STATE Soma à esse tempo o tempo para visitar a sala do vértice $v$
			\STATE Atualiza os Graus de Urgência das salas Com o tempo calculado
			\IF {Grau de Urgência atual > $maior$}
				\STATE $maior \leftarrow$ Grau de Urgência atual
			\ENDIF
			\STATE Visita a sala do vértice $v$
		\ENDFOR

		\IF {$aval$ > $limite$}
			\RETURN 0
		\ENDIF

		\IF {Caminho não visita todas as salas do mapa}
			\RETURN $-aval$
		\ENDIF

		\IF {Primeiro vértice do caminho diferente do último vértice do caminho} 
		\STATE \COMMENT{\textit{Ou seja, não é considerado um loop}}
			\RETURN $-aval$
		\ENDIF
	
	\UNTIL $salas\_anterior$ = $salas\_atual$

	\RETURN $aval$
\end{algorithmic}
\end{algorithm}

\subsubsection{Gerador}
\label{gerador}

O programa chamado \texttt{gerador} é utilizado para gerar os candidatos a seqüência de salas ótima do mapa analisado. Esses candidatos são avaliados pelo programa \texttt{avaliador} e de acordo com a avaliação o \texttt{gerador} irá guardar a seqüência como possível ótima, descartar ou continuar utilizando essa seqüência para gerar novas seqüência. 

%\subsubsection{Funcionamento}
%\paragraph{Funcionamento}

O programa \texttt{gerador} utiliza uma classe (tipo de variável) chamada $Agente$ contendo os seguintes atributos:

\begin{itemize}
	\item \texttt{vertice}: Vértice no qual o agente se encontra no momento;
	\item \texttt{caminho}: Vetor de salas que guarda a seqüência de salas que o agente percorreu até chegar no vértice atual;
	\item \texttt{avaliacao}: Avaliação da seqüência de salas do agente;
	\item \texttt{tempo}: Tempo em segundos que o robô levou para percorrer a seqüência de salas até o vértice atual.
\end{itemize}

O \texttt{gerador} recebe apenas um parâmetro como entrada: o nomo do mapa que quer achar a seqüência ótima. O programa inicia criando uma seqüência percorrendo as salas na ordem numérica (Sala 1, sala 2..) e classificada como possível ótima. A seguir o programa cria um $Agente$ em cada sala do mapa para explorar as possibilidades do robô começar em cada sala, esses $agentes$ são organizados em uma fila de candidatos.

O laço principal do programa consiste em retirar um $agente$ da fila e para cada sala $i$ é criado um novo $agente$, simulando que o $agente$ retirado da fila navegou até a sala $i$. Em cada novo $agente$ é atualizada a seqüência de salas visitadas e o agente é reavaliado. Se a avaliação for um valor negativo o $agente$ é inserido na fila de $agentes$. Se o valor retornado for 0 (zero) o $agente$ é descartado. Caso o avaliador retorne um valor positivo e esse valor é menor que a avaliação da atual seqüência ótima, o novo $agente$ contendo a seqüência melhor é guardado como possível seqüência ótima. Como o algoritmo somente insere na fila os $agentes$ que podem gerar seqüências ótimas, o critério de parada é quando não existe mais $agentes$ na fila, o programa então retorna o $agente$ com a seqüência ótima.

A Figura\ref{fig:fluxograma_gerador} mostra o fluxograma do programa \texttt{gerador} e o algoritmo \ref{alg:gerador} contém seu pseudocódigo.
\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{../../imagens/fluxograma_gerador.png}
	\caption{Fluxograma do \texttt{geradpr}}
	\label{fig:fluxograma_gerador}
\end{figure}
%\subsection{Algoritmo}

\begin{algorithm}[htbp]
\caption{\texttt{gerador}}
\label{alg:gerador}
\begin{algorithmic}[1]
\REQUIRE  mapa
\ENSURE $melhor\_agente$
	\STATE $agente\_otimo.vertice \leftarrow 1$
	\STATE $agente\_otimo.caminho \leftarrow 1, 2, 3...$
	\STATE $agente\_otimo.avaliacao \leftarrow avaliar(agente\_otimo)$
	\FORALL {sala $s$ do mapa}
		\STATE Inicia $agente$ na sala $s$
		\STATE Adiciona $agente$ na $fila$
	\ENDFOR

	\REPEAT
		\STATE Retira o $agente$ do topo da fila
		\FORALL {sala $s$ do mapa}
			\STATE $novo\_agente \leftarrow agente$
			\STATE Atualiza o vértice do $agente$ com a sala $s$
			\STATE Adiciona a sala $s$ ao caminho do $novo\_agente$
			\STATE Avalia o $novo\_agente$ como o caminho atual
			
			\IF {A avaliação for negativa}
				\STATE \COMMENT {\textit{$novo\_agente$ não visitou todas as salas ou não é um loop}}
				\STATE Adiciona o $novo\_agente$ no fim da $fila$
			\ENDIF
			\IF {A avaliação for positiva}
				\STATE \COMMENT {\textit{$novo\_agente$ é melhor que o ótimo atual}}
%				\STATE Coloca o $agente\_otimo$ no fim da fila \COMMENT {\textit{$agente\_otimo$ pode gerar um caminho ótimo}}
				\STATE $agente\_otimo \leftarrow novo\_agente$ \COMMENT {\textit{Atualiza o $agente\_otimo$ com o $novo\_agente$}}
			\ENDIF
		\ENDFOR
	\UNTIL Não exista $agentes$ na fila
	\RETURN $agente\_otimo$

\end{algorithmic}
\end{algorithm}

\newpage
A seguir, uma explicação mais detalhada de como o \texttt{gerador} cria as possíveis seqüências de salas para serem avaliadas. Usarei como exemplo um ambiente com quatro salas. Independente do mapa topológico, o gerador trabalha utilizando um grafo completo contendo somente as salas (Figura \ref{fig:gerador1}).

\begin{figure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{../../imagens/gerador1.png}
	\caption{Grafo completo das salas.}
	\label{fig:gerador1}
\end{figure}

\newpage

O \texttt{gerador} então cria um \textit{agente} em cada sala como mostra a Figura \ref{fig:gerador2}.

\begin{figure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{../../imagens/gerador2.png}
	\caption{Um agente em cada sala, e a fila de \textit{agentes}.}
	\label{fig:gerador2}
\end{figure}

Seguindo o laço principal, o \textit{gerador} remove o primeiro \textit{agente} da fila, no caso é o \textit{agente} \textbf{a} (Figura \ref{fig:gerador3}).

\begin{figure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{../../imagens/gerador3.png}
	\caption{Removendo o \textit{agente} \textbf{a}.}
	\label{fig:gerador3}
\end{figure}

Em seguida o \texttt{gerador} cria uma cópia do \textit{agente} \textbf{a} para cada sala, e simula que esses \textit{agentes} navegaram até sua sala correspondente (Figura \ref{fig:gerador4}). Atualizando o caminho que esse agente percorreu para chegar a essa sala e a avaliação desse caminho.

\begin{figure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{../../imagens/gerador4.png}
	\caption{Inserindo os \textit{agentes} \textbf{e}, \textbf{f} e \textbf{g}.}
	\label{fig:gerador4}
\end{figure}
\newpage
Após feito isso o \texttt{gerador} recomeça o ciclo, removendo o primeiro \textit{agente} da fila (no caso \textit{agente} \textbf{b}), criando outros \textit{agentes} e inserindo-os na fila de acordo com a avaliação adquirida (\textit{agentes} \textbf{h}, \textbf{i} e \textbf{j}) como mostra a Figura \ref{fig:gerador5}.

\begin{figure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{../../imagens/gerador5.png}
	\caption{Removendo o \textit{agente} \textbf{b} e inserindo os \textit{agentes} \textbf{h}, \textbf{i} e \textbf{j}.}
	\label{fig:gerador5}
\end{figure}

\subsection{Tempo Real}
A solução em tempo real inicia as prioridades das salas todas iguais, cada sala recebe um valor correspondente à chance dessa sala gerar uma emergência, como uma lixeira cheia por exemplo. A cada emergência gerada a prioridade da sala é acrescida de uma unidade. O robô segue o paradigma de ir à sala de maior grau de urgência, visita a sala e procura a próxima sala de maior grau de urgência.

A chance de emergência que cada sala recebe é proporcional às prioridades, para fazer o cálculo basta dividir a prioridade da sala pelo soma das prioridades do mapa.

\begin{equation}
	p_s = \frac{P_s}{\sum_{i=1}^{TotalSalas} P_i}
	\label{eq:calc-chances}	
\end{equation}

Isso faz com que a soma das chances seja igual a um. Por exemplo, se em um mapa de quatro salas as prioridades forem:

\begin{table*}[h]
	\centering
		\begin{tabular}
			{|c|c|}
			\hline
			Sala & Prioridade \\
			\hline
			1&5\\
			2&1\\
			3&4\\
			4&5\\					
			\hline
		\end{tabular}
	\caption{Exemplo de prioridades}
	\label{tab:ExemploDePrioridades}
\end{table*}

Suas chances de gerar uma emergência ficaram da seguinte forma:

\begin{table*}[h]
	\centering
		\begin{tabular}
			{|c|c|}
			\hline
			Sala & Chance \\
			\hline
			1&0,333\\
			2&0,067\\
			3&0,267\\
			4&0,333\\					
			\hline
		\end{tabular}
	\caption{Exemplo de chances de emergência}
	\label{tab:ExemploDeChancesDeEmergência}
\end{table*}

\section{Resultados}
\label{resultados}

\section{Conclusão}
\label{conclusao}
