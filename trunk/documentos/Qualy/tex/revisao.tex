%==========================================================
% Capitulo 2: Revisao Bibliografica.
% 
% Autor
% Heitor Luis Polidoro
% 
% Orientador
% Prof. Dr. Denis Fernando Wolf
%==========================================================

\chapter{Revisão Bibliográfica}
\label{revisao_bibliografica}

\section{Busca do Menor Caminho}
\label{busca_do_menor_caminho}
%
\subsubsection{Algoritmo de Dijkstra}
\label{algoritmo_de_dijkstra}
Existem diversos algoritmos para buscas em grafo na literatura \cite{Cormen2001}. Neste trabalho foi utilizado o algoritmo de Dijkstra. O algoritmo de Dijkstra utiliza a técnica do relaxamento, que nada mais é que verifica se é possível melhorar o caminho obtido até o momento passando por um vértice diferente. O algoritmo de Dijkstra apresenta uma solução $O([m + n] × log(n))$ para a determinação do menor caminho \cite{Dudek2000}. E é composto por três passos.

\begin{itemize}
	\item Passo 1: Iniciar os valores:

\begin{algorithmic}
	\FORALL {$v \in V[G]$} 
	\STATE$	d[v] \gets \infty$
	\STATE$ \pi[v] \gets  nulo$
	\ENDFOR
	\STATE	$d[s] \gets 0$
\end{algorithmic}

	$V[G]$ é o conjunto de vértices $v$ que forma o grafo $G$.
	$d[v]$ é o vetor de distâncias do vértice $s$ até cada vértice $v$.
	$\pi[v]$ identifica o vértice de onde se origina uma conexão até $v$ de maneira a formar um caminho mínimo.

	\item Passo 2: Temos que usar dois conjuntos: $S$, que representa todos os vértices $v$ onde $d[v]$ já contém o custo do menor caminho e $Q$ que contém os vértices restantes.

	\item Passo 3: Realizamos uma série de relaxamentos das arestas:
\begin{algorithmic}
	\WHILE {$Q \neq \emptyset $}
		\STATE$u \gets$ \texttt{extraia-mín($Q$)}
		\STATE $S \gets S \cup {u}$
		\FORALL{$v$ adjacente a $u$}
			\STATE se $d[v] > d[u] + w(u, v)$ então 
			\STATE $d[v] \gets d[u] + w(u, v)$
			\STATE $\pi[v] \gets u$
		\ENDFOR
	\ENDWHILE
\end{algorithmic}
		$w(u, v)$ é o peso da aresta que vai de $u$ a $v$.
		$u$ e $v$ são vértices quaisquer e $s$ é o vértice inicial.
		\texttt{extraia-mín($Q$)}, retorna o menor elemento.
		
\end{itemize}
\section{Controle do Robô}
\label{controle_do_robo}
O controle do robô será desenvolvido utilizando-se a biblioteca Player/Stage \cite{Gerkey2003}, a qual permite que sejam realizadas simulações antes que os algoritmos sejam testados com o robô real (Figura \ref{fig:gazebo_pioneer}). Essas simulações são importantes para o aperfeiçoamento dos parâmetros, como distâncias, velocidades, etc, antes do teste no Pioneer.

\begin{figure}[ht]
	\centering
	\subfigure[Gazebo]{
		\includegraphics[width=0.55\textwidth]{../imagens/gazebo.jpg}
		\label{fig:gazebo}}
	\subfigure[Pioneer]{
		\includegraphics[width=0.35\textwidth]{../imagens/pioneer.jpg}
		\label{fig:pioneer}}
	\caption{Robô Pioneer, Simulado e Real.}
	\label{fig:gazebo_pioneer}
\end{figure}

\subsection{Player}
\label{player}
O Player é um servidor de rede para controlar robôs. Executando embarcado no robô, o Player provê uma interface simples e clara dos sensores e atuadores do robô sobre uma rede IP. O programa cliente ``conversa'' com o Player utilizando sockets TPC, lendo dados dos sensores, escrevendo comandos nos atuadores e configurando dispositivos em tempo de execução.
O servidor Player foi desenvolvido para ser independente de linguagem e de plataforma. O programa cliente pode executar em qualquer máquina que tenha conexão de rede com o robô, e pode ser escrito em qualquer linguagem que suporte sockets TCP. Atualmente existem clientes disponíveis em C++, Tcl, Java em Phyton \cite{Player}. Futuramente, o Player não fará suposições sobre como o programa de controle do robô é estruturado, ou seja, poderá-se escrever desde programas multi-threads altamente concorrentes até programas seqüências simples.

\subsection{Stage}
\label{stage}
O Stage é usado normalmente como um plugin para o Player, provendo uma série de dispositivos virtuais para os clientes Player. Os usuários escrevem as rotinas e algoritmos normalmente, como clientes para um servidor Player. Não é possível para clientes distinguir a diferença entre os dispositivos reais do robô e os equivalentes simulados pelo Player/Stage. Com isso clientes Player desenvolvidos usando o Stage precisarão de pouca ou nenhuma modificação para trabalhar com o robô real, e vice-versa. Em muitos casos basta somente mudar no cliente o endereço IP de onde está o servidor. O Stage também pode simular uma população de robôs móveis, sensores e objetos num ambiente bi-dimensional (Figura \ref{fig:stage}) \cite{Player}. Neste projeto será utilizado somente um robô e o sensor LASER.

\figura{../imagens/stage.jpg}{.5}{Simulação com 5 robôs, 2 objetos, LASER, sonar e blobfinder.}{fig:stage}

\subsubsection{Grafos}
\label{grafos}
Muitas aplicações em computação necessitam considerar um conjunto de conexões entre objetos. Os relacionamentos dessas conexões podem ser utilizados para responder questões como: Existe caminho de um objeto a outro? Quantos objetos podem ser alcançados a partir de um determinado objeto? Qual a menor distância entre dois objetos? Existe um tipo abstrato de dados chamado grafo que é usado para modelar essas situações \cite{Ziviani2004}

Um grafo é constituido de um conjunto de vértices e um conjunto de arestas que conectam pares de vértices. Um vértice é um objeto que pode conter nomes e outros atributos. Os grafos podem ser direcionados ou não direcionados. Um grafo direcionado $G$ é um par $(V, A)$, em que $V$ é um conjunto finito de vértices e $A$ é um conjunto de arestas com uma relação binária. A Figura \subref{fig:grafo_dir} mostra um grafo direcionado com o conjunto de vértices $V = {0, 1, 2, 3, 4, 5}$ e de arestas $A = {(0, 1), (0, 3), (1, 2), (1, 3), (2, 2), (2, 3), (3, 0), (5, 4)}$. Em um grafo não direcionado as arestas $(u, v)$ e $(v, u)$ são consideradas as mesmas. A Figura \subref{fig:grefo_ndir} mostra um grafo não direcionado com o conjuntos de vértices $V = {0, 1, 2, 3, 4, 5}$ e de arestas $A = {(0, 1), (0, 2), (1, 2), (4, 5)}$. Em grafos direcionados podem existir arestas de um vértice para ele mesmo, chamades de \textit{self-loops}, como a aresta $(2, 2)$ no grafo diferionado da figura \subref{fig:grafo_dir} \cite{Ziviani2004}.

\begin{figure}[ht]
	\centering
	\subfigure[Grafo direcionado]{
		\includegraphics[width=0.2\textwidth]{../imagens/grafo_direcionado.jpg}
		\label{fig:grafo_dir}}
	\subfigure[Grafo não direcionado]{
		\includegraphics[width=0.2\textwidth]{../imagens/grafo_nao_direcionado.jpg}
		\label{fig:grafo_ndir}}
	\caption{Exemplo de grafos}
	\label{fig:exemplo_de_grafos}
\end{figure}

Em um grafo direcionado, a aresta $(u, v)$ sai do vértice $u$ e entra no vértice $v$. Se $(u, v)$ é uma aresta do grafo $G = (V, A)$, então o vértice $v$ é adjacente ao vértice $u$. Quando o grafo não é direcionado, a relação de adjacência é simétrica \cite{Ziviani2004}.

Em um grafo, um caminho $(v_0, v_1, \cdots, v_k)$ forma um clico se $v_0 = v_k$ e o caminho contém pelo menos uma aresta. O ciclo é simples se os vértices $v_1, v_2, \cdots, v_k$ são distintos. O \textit{self-loop} é um ciclo de tamanho 1. Na figura \subref{fig:grafo_dir}, o caminho $(0, 1, 2, 3, 0)$ forma um ciclo. Dois caminhos $(v_0, v_1, \cdots, v_k)$ e $(v'_0, v'_1, \cdots, v'_k)$ formam o mesmo cliclo se existir um inteiro $j$ tal que $v'_i = v_{(j+i) mod k}$ para $i = 0, 1, \cdots, k - 1$. Na figura \subref{fig:grafo_dir}, o caminho $(0, 1, 3, 0)$ forma o mesmo ciclo que os caminhos $(1, 3, 0, 1)$ e $(3, 0, 1, 3)$. Um grafo sem ciclos é um grafo acíclico \cite{Ziviani2004}.

Um grafo não direcionado é conectado se cada par de vértices está conectado por um caminho. Um grafo direcionado é fortemente conectado se cada dois vértices quaisquer são alcançáveis a partir um do outro. Um grafo ponderado possui pessoa associados às suas arestas. Esses pesos podem representar, por exemplo, custos ou distâncias. Um grafo completo é um grafo não direcionado no qual todos os pares de vértices são adjacentes \cite{Ziviani2004}.

\subsubsection{Navegação}
\label{navegacao}
Existe uma série de problemas não resolvidos na robótica móvel. Uma questão aberte tem a ver com dotar um robô com a habilidade de navegar em seu ambiente \cite{Jones1999}.

Navegação é uma tarefa básica que tem que ser resolvida por um robô móvel autônomo, 

Navegação é a ciência de direcionar o percurso de um robô móvel enquanto percorre o meio ambiente (terra, água, ou ar). Inerente em qualquer esquema de navegação é o desejo de alcançar um destino sem se perder ou colidir com alguma coisa \cite{Mckerrow1991}. Em geral, navegação é um processo incremental que, segundo \cite{Murphy2000}, pode ser resolvido respondendo à quatro perguntas:

\begin{itemize}
	\item \textbf{Para onde estou indo?} Geralmente determinado por um humano ou uma missão;
	\item \textbf{Qual o melhor caminho?} Esse é o problema de planejamento de trajetória, e é a área da navegação que recebe mais atenção;
	\item \textbf{Por onde passei?} Enquanto o robô explora o ambiente, pode ser parte da missão mapear esse ambiente;
	\item \textbf{Onde estou?}	Para seguir uma trajetória ou construir um mapa o robô precisa saber onde ele está.
\end{itemize}

Que podem ser sumarizadas em quatro passos, segundo \cite{Goldberg1995}:

\begin{itemize}
	\item Percepção e modelagem do ambiente;
	\item Localização;	
	\item Planejamento e decição do movimento;	
	\item Execução do movimento;
\end{itemize}

A relação entre esses passos pode ser vista na figura \ref{fig:fluxo_navegacao}

\figura{../imagens/fluxo_navegacao.jpg}{.5}{Hierarquia do controle de um robô móvel, mostrando o fluxo de informação.}{fig:fluxo_nevegação}

Navegação é a instância do paradigma geral da robótica ``perceber - decidir - agir''. A implementação da tarefa de nevegação pode ser mais ou menos complexa, depende do contexto em que a tarefe vai ser executada \cite{Goldberg1995}.

\begin{itemize}
	\item \textbf{O ambiente:} pode ser inicialmente conhecido, parcialmente conhecido, ou completamente desconhecido, pode ser estático ou com objetos móveis, et al.;
	\item \textbf{A meta:} pode ser especificada por \textit{landmarks} ou coordenadas;
	\item \textbf{A navegação em si:} pode ter restrições como: tempo, melhor caminho, et al.;
	\item \textbf{As habilidades do robô:} poder de computação, sensores e suas incertezas, tamanho do robô e sua cinemática, et al.
\end{itemize}
